{
    "type": [
        2,
        0,
        1,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        2,
        2,
        2,
        0,
        1,
        2,
        0,
        1,
        3,
        3,
        3,
        3,
        3,
        2,
        0,
        1,
        3,
        3,
        0,
        1,
        3,
        2,
        0,
        1,
        3,
        3,
        3,
        3,
        0,
        1,
        3,
        3,
        3,
        3,
        0,
        1,
        2,
        2,
        2,
        2,
        0,
        1,
        2,
        2,
        2,
        0,
        1,
        3,
        3,
        2,
        0,
        1,
        3,
        3,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        2,
        0,
        1,
        3,
        3,
        2,
        0,
        1,
        3,
        3,
        2,
        0,
        1,
        3,
        3,
        0,
        1,
        3,
        3,
        3,
        3,
        3,
        3,
        0,
        1,
        2,
        2,
        2,
        2,
        0,
        1,
        2,
        2,
        2,
        0,
        1,
        0,
        1,
        3,
        0,
        1,
        0,
        1,
        2,
        2,
        2,
        2,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        0,
        1,
        0,
        1,
        2,
        0,
        1,
        3,
        3,
        2,
        0,
        1,
        3,
        3,
        0,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        0,
        1,
        3,
        3,
        2
    ],
    "data": [
        "\nR version 4.3.1 (2023-06-16 ucrt) -- \"Beagle Scouts\"\nCopyright (C) 2023 The R Foundation for Statistical Computing\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n",
        "> ",
        "library(Rfast)",
        "Loading required package: Rcpp\n",
        "Loading required package: RcppZiggurat\n",
        "Loading required package: RcppParallel\n",
        "\nAttaching package: ‘RcppParallel’\n\n",
        "The following object is masked from ‘package:Rcpp’:\n\n    LdFlags\n\n",
        "\nRfast: 2.1.0\n",
        " ___ __ __ __ __    __ __ __ __ __ _             _               __ __ __ __ __     __ __ __ __ __ __   \n|  __ __ __ __  |  |  __ __ __ __ _/            / \\             |  __ __ __ __ /   /__ __ _   _ __ __\\  \n| |           | |  | |                         / _ \\            | |                        / /          \n| |           | |  | |                        / / \\ \\           | |                       / /          \n| |           | |  | |                       / /   \\ \\          | |                      / /          \n| |__ __ __ __| |  | |__ __ __ __           / /     \\ \\         | |__ __ __ __ _        / /__/\\          \n|    __ __ __ __|  |  __ __ __ __|         / /__ _ __\\ \\        |_ __ __ __ _   |      / ___  /           \n|   \\              | |                    / _ _ _ _ _ _ \\                     | |      \\/  / /       \n| |\\ \\             | |                   / /           \\ \\                    | |         / /          \n| | \\ \\            | |                  / /             \\ \\                   | |        / /          \n| |  \\ \\           | |                 / /               \\ \\                  | |       / /          \n| |   \\ \\__ __ _   | |                / /                 \\ \\     _ __ __ __ _| |      / /          \n|_|    \\__ __ __\\  |_|               /_/                   \\_\\   /_ __ __ __ ___|      \\/             team\n",
        "> ",
        "dirimultinom.mle",
        "function (x, tol = 1e-07) \n{\n    dm <- dim(x)\n    p <- dm[2]\n    n <- dm[1]\n    rs <- sum(x[1, ])\n    a1 <- Rfast::colmeans(x)/rs\n    x <- t(x)\n    y <- x + a1\n    sa <- sum(a1)\n    lik1 <- n * lgamma(sa) - sum(Rfast::Lgamma(rs + sa)) - n * \n        sum(lgamma(a1)) + sum(Rfast::Lgamma(y))\n    f <- n * digamma(sa) - sum(Rfast::Digamma(rs + sa)) - n * \n        digamma(a1) + Rfast::rowsums(Rfast::Digamma(y))\n    f2 <- matrix(n * trigamma(sa) - sum(Rfast::Trigamma(rs + \n        sa)), p, p)\n    diag(f2) <- diag(f2) - n * trigamma(a1) + Rfast::rowsums(Rfast::Trigamma(y))\n",
        "    a2 <- a1 - solve(f2, f)\n    sa <- sum(a2)\n    y <- x + a2\n    lik2 <- n * lgamma(sa) - sum(lgamma(rs + sa)) - n * sum(lgamma(a2)) + \n        sum(Rfast::Lgamma(y))\n    i <- 2\n    while (lik2 - lik1 > tol) {\n        i <- i + 1\n        lik1 <- lik2\n        a1 <- a2\n        f <- n * digamma(sa) - sum(Rfast::Digamma(rs + sa)) - \n            n * digamma(a1) + Rfast::rowsums(Rfast::Digamma(y))\n        f2 <- matrix(n * trigamma(sa) - sum(Rfast::Trigamma(rs + \n            sa)), p, p)\n        diag(f2) <- diag(f2) - n * trigamma(a1) + Rfast::rowsums(Rfast::Trigamma(y))\n",
        "        a2 <- a1 - solve(f2, f)\n        sa <- sum(a2)\n        y <- x + a2\n        lik2 <- n * lgamma(sa) - sum(Rfast::Lgamma(rs + sa)) - \n            n * sum(lgamma(a2)) + sum(Rfast::Lgamma(y))\n    }\n    list(iters = i, loglik = lik2, param = a2)\n}\n<bytecode: 0x000002ad7f2f5c50>\n<environment: namespace:Rfast>\n",
        "> ",
        "multinom.mle",
        "function (x) \n{\n    N <- sum(x[1, ])\n    p <- Rfast::colmeans(x)/N\n    n <- dim(x)[1]\n    loglik <- n * lgamma(N + 1) + sum(p * log(p)) * N * n - sum(Rfast::Lgamma(x + \n        1))\n    list(loglik = loglik, prob = p)\n}\n<bytecode: 0x000002ad7f31b2c8>\n<environment: namespace:Rfast>\n",
        "> ",
        "install.packages(\"bp\")",
        "Installing package into ‘C:/Users/mtsag/AppData/Local/R/win-library/4.3’\n(as ‘lib’ is unspecified)\n",
        "trying URL 'https://cran.rstudio.com/bin/windows/contrib/4.3/bp_2.1.0.zip'\n",
        "Content type 'application/zip'",
        " length 1918598 bytes (1.8 MB)\n",
        "downloaded 1.8 MB\n\n",
        "package ‘bp’ successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n\tC:\\Users\\mtsag\\AppData\\Local\\Temp\\RtmpWggU0D\\downloaded_packages\n",
        "> ",
        "library(bp)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "> ",
        "bp.mle",
        "Error: object 'bp.mle' not found\n",
        "\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "\nAttaching package: ‘MLE’\n\n",
        "The following object is masked from ‘package:Rfast’:\n\n    ordinal.mle\n\n",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "> ",
        "library(Compositional)",
        "\nCompositional: 6.9\n",
        "  _ _ _ _\n /   _ _ _\\\n/  /\n| |           _ _ _ _     _    _     _ _ _ _    _ _ _ _    _ _ _ _    _      _      _    _ _ _ _    _ _ _ _    _ _ _ _      _\n| |          |  _ _  |   / \\  / \\   |  _ _  |  |  _ _  |  |  _ _ _/  |_|   _| |_   |_|  |  _ _  |  /  _ _  \\  /  _ _  \\    | |\n| |          | |   | |  |   \\/   |  | |   | |  | |   | |  |_ _ _  |   _   |_   _|   _   | |   | |  | |   | |  | |   | |    | |\n\\  \\ _ _ _   | |_ _| |  | |\\__/| |  | |_ _| |  | |_ _| |   _ _ _| |  | |    | |_   | |  | |_ _| |  | |   | |  | |_ _| \\_   | |\n \\_ _ _ _ /  |_ _ _ _|  |_|    |_|  |  _ _ _|  |_ _ _ _|  /_ _ _ _|  |_|    |_ _\\  |_|  |_ _ _ _|  |_|   |_|  \\_ _ _ _ _/  |_|\n                                    | |\n                                    |_|\n",
        "\nAttaching package: ‘Compositional’\n\n",
        "The following objects are masked from ‘package:Rfast’:\n\n    bc, spatmed.reg\n\n",
        "> ",
        "zad.est",
        "function(y) {\n  ## y is the compositional data\n  ## x is the independent variable(s)\n  dm <- dim(y)\n  D <- dm[2]   ;   d <- D - 1\n  ## d is the dimensionality of the simplex\n  n <- dm[1] ## sample size\n  x <- matrix(1, nrow = n, ncol = 1)\n  runtime <- proc.time()\n  ## next we separate the compositional vectors, those which contain\n  ## zeros and those without. The same separation is performed for the\n  ## independent variable(s)\n  a1 <- which( Rfast::rowsums( y > 0 ) == D )\n  a2 <- which( Rfast::rowsums( y > 0 ) != D )\n",
        "  n1 <- length(a1)\n  n2 <- n - n1\n  ## n1 is the sample size of the compositional vectors with no zeros\n  ## n2 is the sample size of the compositional vectors with zeros\n  za <- y[a2, , drop = FALSE]\n  za[za == 0] <- 1\n  za[ za < 1 ] <- 0\n  theta <- table( apply(za, 1, paste, collapse = \",\") )\n  theta <- as.vector(theta)\n  con <- n1 * log(n1/n) + sum( theta * log(theta/n) )\n\n  y1 <- y[a1, , drop = FALSE]\n  ly1 <- log( y1 )\n  x1 <- x[a1, , drop = FALSE]\n  ly2 <- log( y[a2, , drop = FALSE] )\n  x2 <- x[a2, , drop = FALSE]\n",
        "  n1 <- nrow(y1)    ;    n2 <- n - n1\n  beta.ini <- .lm.fit(x1, ly1[, -1] - ly1[, 1])$coefficients\n  ini.phi <- sum( Compositional::diri.nr(y1, type = 2)$param )\n  ##############\n  ini.par <- c( log(ini.phi), as.vector( t( beta.ini) ) )  ## initial parameter values\n  z <- list(ly1 = ly1, ly2 = ly2, x1 = x1, x2 = x2, a1 = a1, a2 = a2)\n  suppressWarnings({\n    qa <- optim( ini.par, .mixreg, z = z, hessian = TRUE, control = list(maxit = 10000) )\n    qa <- optim( qa$par, .mixreg, z = z, hessian = TRUE, control = list(maxit = 10000) )\n",
        "  })\n  phi <- exp( qa$par[1] )  ## final phi value\n  mu <- c(1, exp(qa$par[-1]) ) ## final beta values\n  mu <- mu / sum(mu)\n\n  runtime <- proc.time() - runtime\n\n  list(loglik = -qa$value + con, phi = phi, mu = mu, runtime = runtime)\n}\n<bytecode: 0x000001ba84c13330>\n<environment: namespace:Compositional>\n",
        "> ",
        "Rfast2::kumar.mle",
        "function (x, tol = 1e-07, maxiters = 50) \n{\n    n <- length(x)\n    lx <- log(x)\n    slx <- sum(lx)\n    ini <- Rfast::beta.mle(x)$param\n    expa <- ini[1]\n    expb <- ini[2]\n    xa <- x^expa\n    ya <- 1 - xa\n    com <- xa * lx/ya\n    scom <- sum(com)\n    derab <- -expb * expa * scom\n    dera <- n + expa * slx + (1 - 1/expb) * derab\n    dera2 <- expa * slx - (expb - 1) * expa^2 * sum(com * lx/ya)\n    derb2 <- expb * sum(log(ya))\n    derb <- n + derb2\n    aold <- c(log(expa), log(expb))\n    anew <- aold - c(derb2 * dera - derab * derb, -derab * dera + \n",
        "        dera2 * derb)/(dera2 * derb2 - derab^2)\n    i <- 2\n    while (sum(abs(anew - aold)) > tol & i < maxiters) {\n        i <- i + 1\n        aold <- anew\n        expa <- exp(aold[1])\n        expb <- exp(aold[2])\n        xa <- x^expa\n        ya <- 1 - xa\n        com <- xa * lx/ya\n        scom <- sum(com)\n        derab <- -expb * expa * scom\n        dera <- n + expa * slx + (1 - 1/expb) * derab\n        dera2 <- expa * slx - (expb - 1) * expa^2 * sum(com * \n            lx/ya)\n        derb2 <- expb * sum(log(ya))\n",
        "        derb <- n + derb2\n        anew <- aold - c(derb2 * dera - derab * derb, -derab * \n            dera + dera2 * derb)/(dera2 * derb2 - derab^2)\n    }\n    a <- exp(anew[1])\n    b <- exp(anew[2])\n    param <- c(a, b)\n    loglik <- n * log(a * b) + (a - 1) * slx + (b - 1) * derb2/expb\n    names(param) <- c(\"shape\", \"scale\")\n    list(iters = i, param = param, loglik = loglik)\n}\n<bytecode: 0x000001ba6f9702f0>\n<environment: namespace:Rfast2>\n\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "> ",
        "library(Compositional)",
        "> ",
        "alpha.mle(x)",
        "Error: object 'x' not found\n",
        "> ",
        "?alpha.mle(x)",
        "> ",
        "x <- as.matrix(iris[, 1:4])",
        "> ",
        "x <- x / rowSums(x)",
        "> ",
        "mod <- alfa.tune(x)",
        "> ",
        "x <- as.matrix(iris[, 1:4])",
        "> ",
        "x <- x / rowSums(x)",
        "> ",
        "mod <- a.mle(x)",
        "Error in a.mle(x) : argument \"x\" is missing, with no default\n",
        "> ",
        "a.mle",
        "function(a, x) {\n  ## x is the compositional data\n  ## a is the value of the alpha parameter\n  dm <- dim(x)\n  n <- dm[1]    ;    D <- dm[2]   ## dimensions of x\n  d <- D - 1  ## dimensionality of the simplex\n  ja <- sum( Rfast::Log(x) )  ## part of the Jacobian determinant\n  #########\n  if ( abs(a) < 1e-9 ) {\n    aff <- Compositional::alef(x, 0)$aff\n    su <- Rfast::cova(aff)\n    loglik <-  - 0.5 * n * d - 0.5 * n * log( abs( det(2 * pi * (n - 1)/n * su) ) ) - ja - n/2 * log(D)\n\n  } else {\n    mod <- Compositional::alef(x, a)\n",
        "    y <- mod$aff\n    sk <- mod$sk\n    lam <- 1 / ( a^2 * Rfast::rowMins(y, value = TRUE)^2 )    ##  1/apply(a * y, 1, min)^2\n    y1 <- y %*% t( helm(D) )\n    y2 <- y1 * lam\n    com <-  - 0.5 * n * d * log(2 * pi ) + n * (d + 0.5) * log(D) + (a - 1) * ja - D * sum( log(sk) ) + 0.5 * d\n    ## step 1\n    ma <- Rfast::colmeans(y1)\n    sa <- Rfast::cova(y1)\n    f1 <- exp( -0.5 * Rfast::mahala(y1, ma, sa) )\n    f2 <- lam^d * exp(-0.5 * Rfast::mahala(y2, ma, sa) )\n    p <- f1/(f1 + f2)\n    per <- sum(p) / n\n    ela1 <- sum( log(per * f1 + (1 - per) * f2), na.rm = TRUE ) - 0.5 * n * log( det(sa) )\n",
        "    ma <- colMeans(p * y1 + (1 - p) * y2, na.rm = TRUE)\n    z1 <- sqrt(p) * ( y1 - rep(ma, rep(n, d)) )\n    z1 <- na.omit(z1)\n    z2 <- sqrt(1 - p) * ( y2 - rep(ma, rep(n, d)) )\n    z2 <- na.omit(z2)\n    sa <- ( crossprod(z1) + crossprod(z2) )/n\n    f1 <- exp( -0.5 * Rfast::mahala(y1, ma, sa) )\n    f2 <- lam^d * exp( -0.5 * Rfast::mahala(y2, ma, sa) )\n    p <- f1/(f1 + f2)\n    per <- sum(p) / n\n    ela2 <- sum( log(per * f1 + (1 - per) * f2), na.rm = TRUE ) - 0.5 * n * log( det(sa) )\n\n    while ( abs(ela2 - ela1 ) > 1e-06 ) {\n",
        "      ela1 <- ela2\n      ma <- colMeans(p * y1 + (1 - p) * y2, na.rm = TRUE)\n      z1 <- sqrt(p) * ( y1 - rep(ma, rep(n, d)) )\n      z1 <- na.omit(z1)\n      z2 <- sqrt(1 - p) * ( y2 - rep(ma, rep(n, d)) )\n      z2 <- na.omit(z2)\n      sa <- ( crossprod(z1) + crossprod(z2) )/n\n      f1 <- exp( -0.5 * Rfast::mahala(y1, ma, sa) )\n      f2 <- lam^d * exp( -0.5 * Rfast::mahala(y2, ma, sa) )\n      p <- f1 / (f1 + f2)\n      per <- sum(p) / n\n      ela2 <- sum( log(per * f1 + (1 - per) * f2), na.rm = TRUE ) - 0.5 * n * log( det(sa) )\n",
        "    }  ## end while ( abs(ela2 - ela1 ) > 1e-06 )\n    loglik <- ela2 + com\n  }  ## end if ( abs(a) < 1e-9)\n\n  loglik\n}\n<bytecode: 0x000001f68bffa2c0>\n<environment: namespace:Compositional>\n",
        "> ",
        "a.mle(0.1,x)",
        "[1] 1007.099\n",
        "> ",
        "alpha.mle(x,0.1)",
        "$iters\n[1] 3\n\n$p\n[1] 1\n\n$loglik\n[1] 1007.099\n\n$mu\n[1] 0.4739027 0.2237920 1.2573922\n\n$su\n            [,1]        [,2]       [,3]\n[1,]  0.02067757 -0.06171029 -0.0717613\n[2,] -0.06171029  0.23122235  0.2795894\n[3,] -0.07176130  0.27958938  0.3764997\n\n",
        "> ",
        "a.est",
        "function(x) {\n  ## x contains compositional data\n   runtime <- proc.time()\n   opt <- optimize( a.mle, c(-1, 1), x = x, maximum = TRUE )\n   best <- opt$maximum\n   mod <- Compositional::alpha.mle(x, best)\n   runtime <- proc.time() - runtime\n   list(runtime = runtime, best = best, loglik = mod$loglik,\n        p = mod$p, mu = mod$mu, su = mod$su)\n}\n<bytecode: 0x000001f68c4f3cb8>\n<environment: namespace:Compositional>\n",
        "> ",
        "a.est(x)",
        "$runtime\n   user  system elapsed \n   0.02    0.00    0.02 \n\n$best\n[1] 0.7099638\n\n$loglik\n[1] 1040.383\n\n$p\n[1] 0.9999513\n\n$mu\n[1] 0.5406432 0.2577742 0.9181809\n\n$su\n            [,1]        [,2]        [,3]\n[1,]  0.01421689 -0.04411902 -0.02245803\n[2,] -0.04411902  0.23688371  0.13372228\n[3,] -0.02245803  0.13372228  0.08197066\n\n",
        "> ",
        "alpha.mle(x,0.7099)",
        "$iters\n[1] 4\n\n$p\n[1] 0.9999514\n\n$loglik\n[1] 1040.383\n\n$mu\n[1] 0.5406388 0.2577741 0.9182113\n\n$su\n            [,1]        [,2]       [,3]\n[1,]  0.01421734 -0.04412102 -0.0224610\n[2,] -0.04412102  0.23688851  0.1337355\n[3,] -0.02246100  0.13373548  0.0819851\n\n\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "> ",
        "library(Directional)",
        "The legacy packages maptools, rgdal, and rgeos, underpinning the sp package,\nwhich was just loaded, will retire in October 2023.\nPlease refer to R-spatial evolution reports for details, especially\nhttps://r-spatial.org/r/2023/05/15/evolution4.html.\nIt may be desirable to make the sf package available;\npackage maintainers should consider adding sf to Suggests:.\nThe sp package is now running under evolution status 2\n     (status 2 uses the sf package in place of rgdal)\n",
        "\nDirectional: 6.8\n",
        " _ _ _\n|  _ _ \\\n| |   | |   _    _        _ _ _ _    _ _ _ _      _      _    _ _ _ _    _ _ _ _    _ _ _ _      _ \n| |   | |  |_|  | |_ _   |   __  |  |  _ _ _\\   _| |_   |_|  |  _ _  |  /  _ _  \\  /  _ _  \\    | |\n| |   | |   _   |  _ _\\  |  _ _ _|  | |        |_   _|   _   | |   | |  | |   | |  | |   | |    | |\n| |_ _| |  | |  | |      |  \\_ _    | |_ _ _     | |_   | |  | |_ _| |  | |   | |  | |_ _| \\_   | |\n|_ _ _ /   |_|  |_|       \\_ _ _\\   |_ _ _ _/    |_ _\\  |_|  |_ _ _ _|  |_|   |_|  \\_ _ _ _ _/  |_|\n",
        "\nAttaching package: ‘Directional’\n\n",
        "The following object is masked from ‘package:Compositional’:\n\n    makefolds\n\n",
        "The following objects are masked from ‘package:Rfast’:\n\n    acg.mle, circlin.cor, colvm.mle, colwatsons, dirknn, iag.mle, kuiper, mediandir, multivmf.mle,\n    racg, rbingham, rvmf, rvonmises, spml.mle, spml.reg, spml.regs, vmf.mle, watson,\n    wrapcauchy.mle\n\n",
        "> ",
        "spcauchy.mle",
        "function(x, tol = 1e-6) {\n\n  dm <- dim(x)\n  n <- dm[1]  ;  d <- dm[2] - 1\n  mu <- Rfast::colmeans(x)\n  g2 <- sum(mu^2)\n  a <- as.vector(x %*% mu)\n  com <- sqrt(g2 + 1)\n  com2 <- 1 / (com - a)\n  lik <- -sum( log( sqrt(g2 + 1) - a ) )\n  up <- Rfast::eachrow(x, mu / com, oper = \"-\" )\n  der <- Rfast::eachcol.apply(up, com2)\n  #up1 <- Rfast::Outer( as.vector( ( diag(com, 2) - tcrossprod(mu) / com ) / com^2 ), com2, oper = \"/\" )\n  #up1 <- matrix( Rfast::colsums(up1), ncol = 2)\n  up1 <- ( diag(com, d + 1) - tcrossprod(mu) / com ) / com^2 * sum(com2)\n",
        "  up2 <- crossprod(up * com2)\n  der2 <- up2 - up1\n\n  mu <- mu - solve(der2, der)\n  g2 <- sum(mu^2)\n  a <- as.vector(x %*% mu)\n  com <- sqrt(g2 + 1)\n  com2 <- 1 / (com - a)\n  lik[2] <- d * sum( log( com2 ) )\n\n  i <- 2\n  while ( lik[i] - lik[i - 1] > tol ) {\n    i <- i + 1\n    up <- Rfast::eachrow(x, mu / com, oper = \"-\" )\n    der <- Rfast::eachcol.apply(up, com2)\n    #up1 <- Rfast::Outer( as.vector( ( diag(com, 2) - tcrossprod(mu) / com ) / com^2 ), com2, oper = \"/\" )\n    #up1 <- matrix( Rfast::colsums(up1), ncol = 2)\n",
        "    up1 <- ( diag(com, d + 1) - tcrossprod(mu) / com ) / com^2 * sum(com2)\n    up2 <- crossprod(up * com2)\n    der2 <- up2 - up1\n    mu <- mu - solve(der2, der)\n    a <- as.vector(x %*% mu)\n    g2 <- sum(mu^2)\n    com <- sqrt(g2 + 1)\n    com2 <- 1 / ( com - a )\n    lik[i] <- d * sum( log( com2 ) )\n  }\n  gamma <- sqrt( sum(mu^2) )\n  list( mesos = mu, mu = mu / gamma, gamma = gamma, rho = (com - 1) / gamma, loglik = lik[i] +\n        n * lgamma( 0.5 * (d + 1) ) - 0.5 * n * (d + 1) * log(pi) - n * log(2) )\n}\n<bytecode: 0x0000025f88e459a0>\n",
        "<environment: namespace:Directional>\n",
        "> ",
        "spcauchy.mle2",
        "function(x, tol = 1e-6) {\n\n  dm <- dim(x)\n  n <- dm[1]  ;  d <- dm[2] - 1\n\n  sp <- function(rho, mu, x, n, d) {\n    a <- as.vector(x %*% mu)\n    n * d * log(1 - rho^2) - d * sum( log1p( rho^2 - 2 * rho * a ) )\n  }\n\n  mu <- Rfast::colmeans(x)\n  mu <- mu / sqrt(sum(mu^2) )\n  mod <- optimize(sp, c(0, 1), mu = mu, x = x, n = n, d = d, maximum = TRUE, tol = 1e-6 )\n  rho <- mod$maximum\n  lik1 <- mod$objective\n\n  down <- 1 + rho^2 - 2 * rho * as.vector( x %*% mu)\n  mu <- Rfast::eachcol.apply(rho * x, down, oper = \"/\")\n",
        "  mu <- mu / sqrt( sum(mu^2) )\n  mod <- optimize(sp, c(0, 1), mu = mu, x = x, n = n, d = d, maximum = TRUE, tol = 1e-6 )\n  rho <- mod$maximum\n  lik2 <- mod$objective\n\n  while ( abs( lik2 - lik1 ) > tol ) {\n    lik1 <- lik2\n    down <- 1 + rho^2 - 2 * rho * as.vector( x %*% mu)\n    mu <- Rfast::eachcol.apply(rho * x, down, oper = \"/\")\n    mu <- mu / sqrt( sum(mu^2) )\n    mod <- optimize(sp, c(0, 1), mu = mu, x = x, n = n, d = d, maximum = TRUE, tol = 1e-6 )\n    rho <- mod$maximum\n    lik2 <- mod$objective\n  }\n",
        "\n  list(mu = mu, rho = rho, loglik = lik2 + n * lgamma( 0.5 * (d + 1) ) - 0.5 * n * (d + 1) * log(pi) - n * log(2) )\n}\n<bytecode: 0x0000025f88e09270>\n<environment: namespace:Directional>\n",
        "> ",
        "?spcauchy.mle",
        "> ",
        "kentl.mle",
        "Error: object 'kentl.mle' not found\n",
        "> ",
        "library(Directional)",
        "> ",
        "kent.mle",
        "function(x) {\n  ## x is the data in Euclidean coordinates\n  tic <- proc.time()\n  n <- dim(x)[1]  ## sample size\n  xbar <- Rfast::colmeans(x)  ## mean vector\n  S <- crossprod(x) / n\n  xbar <- xbar / sqrt( sum(xbar^2) ) ## mean direction\n  u <- c( acos(xbar[1]), ( atan(xbar[3] / xbar[2]) + pi * I(xbar[2]<0) )\n  %% (2 * pi) )\n  ## u is the mean vector to latitude and longitude\n  theta <- u[1]\n  phi <- u[2]\n  costheta <- cos(theta)\n  sintheta <- sin(theta)\n  cosphi <- cos(phi)\n  sinphi <- sin(phi)\n  H <- matrix( c(costheta, sintheta * cosphi, sintheta * sinphi, -sintheta, costheta * cosphi,\n",
        "       costheta * sinphi, 0, -sinphi, cosphi), ncol = 3 )\n  B <- crossprod(H, S) %*% H\n  psi <- 0.5 * atan(2 * B[2, 3]/(B[2, 2] - B[3, 3]))\n  K <- matrix( c(1, 0, 0, 0, cos(psi), sin(psi), 0, -sin(psi), cos(psi) ), ncol = 3)\n  G <- H %*% K  ## The G matrix Kent describes, the A in our notation\n  lam <- eigen(B[-1, -1])$values\n  ## the next function will be used to estimate the kappa and beta\n  xg <- x %*% G\n  xg1 <- sum(xg[, 1])\n  a <- Rfast::colsums(xg[, 2:3]^2)\n  xg2 <- a[1]\n  xg3 <- a[2]\n\n  mle <- function(para) {\n",
        "    ## maximization w.r.t. to k and b\n    k <- para[1]\n    b <- para[2]\n    gam <- c(0, k, 0)\n    lam <- c(0, -b, b)\n    ckb <- fb.saddle(gam, lam)[3]\n    g <-  n * ckb - k * xg1 - b * ( xg2 - xg3 )\n    g\n  }\n\n  ini <- Rfast::vmf.mle(x)$kappa\n  ini <- c(ini, ini/2.1)  ## initial values for kappa and beta\n  qa <- optim(ini, mle)\n  para <- qa$par\n  k <- para[1]\n  b <- para[2]  ## the estimated parameters\n  gam <- c(0, k, 0)\n  lam <- c(0, -b, b)\n  ckb <- as.numeric( fb.saddle(gam, lam)[3] )\n  ## the line below calculates the log-likelihood\n",
        "  l <-  -n * ckb + k * xg1 + b * ( xg2 - xg3 )\n  param <- c(k, b, psi)\n  runtime <- proc.time() - tic\n  names(param) <- c(\"kappa\", \"beta\", \"psi\")\n  colnames(G) <- c(\"mean\", \"major\", \"minor\")\n  list(G = G, param = param, logcon = ckb, loglik = l, runtime = runtime)\n}\n<bytecode: 0x0000025f8b59e9d8>\n<environment: namespace:Directional>\n",
        "> ",
        "esag.mle",
        "function(y, full = FALSE, tol = 1e-06) {\n  ## y is the spherical data, a matrix with unit vectors\n  n <- dim(y)[1]\n  I3 <- diag(3)\n  z <- t(y)\n  nc <- n/2\n\n   mag <- function(param, z, nc, I3) {\n     m <- param[1:3]\n     gam1 <- param[4]\n     gam2 <- param[5]\n     heta <- sqrt(gam1^2 + gam2^2 + 1) - 1\n     m0 <- sqrt( m[2]^2 + m[3]^2 )\n     rl <- sum(m^2)\n     x1b <- c( -m0^2, m[1] * m[2], m[1] * m[3] ) / m0 / sqrt(rl)\n     x2b <- c( 0, -m[3], m[2] )/m0\n     T1 <- tcrossprod( x1b )\n     T2 <- tcrossprod( x2b )\n",
        "     T12 <- tcrossprod( x1b, x2b )\n     vinv <- I3 + gam1 * ( T1 - T2 ) + gam2 * ( T12 + t(T12) ) + heta * ( T1 + T2 )\n     g2 <- colSums( m * z )\n     g1 <- colSums( z * crossprod(vinv, z) )\n     a <- g2 / sqrt(g1)\n     a2 <- a^2\n     M2 <- ( 1 + a2 ) * pnorm(a) + a * dnorm(a)\n     - 0.5 * sum(a2) + nc * rl + 1.5 * sum( log(g1) ) - sum( log(M2) )\n   }\n\n  suppressWarnings({\n  mod <- Rfast::iag.mle(y)\n  da <- nlm(mag, c(mod$mesi[1, ], rnorm(2) ), z = z, nc = nc, I3 = I3, iterlim = 5000)\n  lik1 <-  -da$minimum\n",
        "  da <- optim(da$estimate, mag, z = z, nc = nc, I3 = I3, control = list(maxit = 10000) )\n  lik2 <-  -da$value\n  while ( lik2 - lik1 > tol) {\n    lik1 <- lik2\n    da <- optim(da$par, mag, z = z, nc = nc, I3 = I3, control = list(maxit = 10000) )\n    lik2 <-  -da$value\n  }\n  })\n  if ( full ) {\n    mu <- da$par[1:3]\n    gam1 <- da$par[4]  ;    gam2 <- da$par[5]\n    heta <- sqrt(gam1^2 + gam2^2 + 1) - 1\n    m0 <- sqrt( mu[2]^2 + mu[3]^2 )\n    rl <- sum(mu^2)\n    x1b <- c( -m0^2, mu[1] * mu[2], mu[1] * mu[3] ) / m0 / sqrt(rl)\n",
        "    x2b <- c( 0, -mu[3], mu[2] )/m0\n    T1 <- tcrossprod( x1b )   ;     T2 <- tcrossprod( x2b )\n    T12 <- tcrossprod( x1b, x2b )\n    vinv <- I3 + gam1 * ( T1 - T2 ) + gam2 * ( T12 + t(T12) ) + heta * ( T1 + T2 )\n    rho <- heta + 1 - 0.5 * sqrt( (2 * heta + 2 )^ 2 - 4 )\n    psi <- 0.5 * acos( 2 * gam1 / (1/rho - rho ) )\n    res <- res <- list( mu = da$par[1:3], gam = c(gam1, gam2), loglik = lik2 - n * log(2 * pi),\n                        vinv = vinv, rho = rho, psi = psi, iag.loglik = mod$param[2])\n  } else  res <- list( mu = da$par[1:3], gam = da$par[4:5], loglik = lik2 - n * log(2 * pi),\n",
        "                       iag.loglik = mod$param[2])\n  res\n}\n<bytecode: 0x0000025f8b409878>\n<environment: namespace:Directional>\n",
        "> ",
        "sespc.mle",
        "function(y, full = FALSE, tol = 1e-6) {\n\n  n <- dim(y)[1]\n  I3 <- diag(3)\n   mag <- function(param, y, I3) {\n     m <- param[1:3]\n     the1 <- param[4]\n     the2 <- param[5]\n     heta <- sqrt(the1^2 + the2^2 + 1) - 1\n     m0 <- sqrt(m[2]^2 + m[3]^2)\n     rl <- sum(m^2)  ## gamma^2\n     x1b <- c( -m0^2, m[1] * m[2], m[1] * m[3] ) / ( m0 * sqrt(rl) )\n     x2b <- c(0, -m[3], m[2])/m0\n     T1 <- tcrossprod(x1b)\n     T2 <- tcrossprod(x2b)\n     T12 <- tcrossprod(x1b, x2b)\n     vinv <- I3 + the1 * (T1 - T2) + the2 * ( T12 + t(T12) ) +\n",
        "             heta * (T1 + T2)\n     a <- as.vector( y %*% m )\n     b <- Rfast::rowsums( y %*% vinv * y )\n     E <- b * rl + b - a^2\n     sqe <- sqrt(E)\n     up <- log( b * (rl + 1) * sqe * ( atan2(sqe, -a) - atan2(sqe, a) + pi ) + 2 * a * E )\n     down <- log( b * E^2 )\n     - sum(up) + sum(down)\n   }\n  mod <- Directional::sipc.mle(y)\n  da <- nlm( mag, c( mod$mu, rnorm(2) ), y = y, I3 = I3, iterlim = 10000 )\n  lik1 <-  -da$minimum\n  da <- optim( da$estimate, mag, y = y, I3 = I3, control = list(maxit = 10000) )\n",
        "  lik2 <-  -da$value\n  while (lik2 - lik1 > tol) {\n    lik1 <- lik2\n    da <- optim( da$par, mag, y = y, I3 = I3, control = list(maxit = 10000) )\n    lik2 <-  -da$value\n  }\n\n  if (full) {\n    m <- da$par[1:3]\n    the1 <- da$par[4]\n    the2 <- da$par[5]\n    theta <- sqrt(the1^2 + the2^2 + 1) - 1\n    m0 <- sqrt(m[2]^2 + m[3]^2)\n    rl <- sum(m^2)  ## gamma^2\n    x1b <- c( -m0^2, m[1] * m[2], m[1] * m[3] ) / ( m0 * sqrt(rl) )\n    x2b <- c(0, -m[3], m[2])/m0\n    T1 <- tcrossprod(x1b)\n    T2 <- tcrossprod(x2b)\n    T12 <- tcrossprod(x1b, x2b)\n",
        "    vinv <- I3 + the1 * (T1 - T2) + the2 * ( T12 + t(T12) ) + theta * (T1 + T2)\n    lam2 <- theta + 1 - 0.5 * sqrt( (2 * theta + 2 )^ 2 - 4 )\n    psi <- 0.5 * acos( 2 * the1 / (1/lam2 - lam2 ) )\n    res <- list(mu = m, theta = c(the1, the2), loglik = lik2 - n * log(4 * pi^2),\n                vinv = vinv, lambda = lam2, psi = psi, sipc.loglik = mod$loglik)\n  } else  res <- list(mu = da$par[1:3], theta = da$par[4:5], loglik = lik2 - n * log(4 * pi^2), sipc.loglik = mod$loglik )\n\n  res\n}\n<bytecode: 0x0000025f8af4ff80>\n",
        "<environment: namespace:Directional>\n",
        "> ",
        "?sespc.mle",
        "> ",
        "?kent.mle",
        "\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "> ",
        "wood.mle",
        "function(y) {\n  ## y is a two column matrix, where the first column is the latitude and\n  ## the second is the longitude, all expressed in degrees\n  y[, 1] <- 90 - y[, 1] ## we want the co-latitude\n  y <- y / 180 * pi\n  siny1 <- sin( y[, 1] )\n  x <- cbind( siny1 * cos(y[, 2]), siny1 * sin(y[, 2]), cos(y[, 1]) )\n  #################\n    mle <- function(param) {\n      gam <- param[1]  ;  del <- param[2]\n      m1 <- c( cos(gam) * cos(del), cos(gam) * sin(del), - sin(gam) )\n      m2 <- c( - sin(del), cos(del), 0 )\n",
        "      m3 <- c( sin(gam) * cos(del), sin(gam) * sin(del), cos(gam) )\n      a1 <- as.vector( x %*% m1 )\n      a2 <- as.vector( x %*% m2 )\n      a3 <- as.vector( x %*% m3 )\n      u <- sum(a3)\n      down <- sqrt( 1 - a3^2 )\n      v <- sum( ( a1^2 - a2^2 ) / down )\n      w <- 2 * sum( a1 * a2  / down )\n      - u^2 - v^2 - w^2\n    }\n    #############\n    lik <- function(k) {\n      - n * log( ( exp(k) - exp(-k) ) / k ) +\n      k * ( u * cos(a) + ( v * cos(b) + w * sin(b) ) * sin(a) )\n    }\n  ##############\n  ini <- Rfast::colmeans(y)\n",
        "  mod <- optim( ini, mle )\n  mod <- optim(mod$par, mle, hessian = TRUE)\n  gam <- mod$par[1]     ;     del <- mod$par[2]\n  m1 <- c( cos(gam) * cos(del), cos(gam) * sin(del), - sin(gam) )\n  m2 <- c( - sin(del), cos(del), 0 )\n  m3 <- c( sin(gam) * cos(del), sin(gam) * sin(del), cos(gam) )\n\n  a1 <- as.vector( x %*% m1 )\n  a2 <- as.vector( x %*% m2 )\n  a3 <- as.vector( x %*% m3 )\n  u <- sum(a3)\n  down <- sqrt( 1 - a3^2 )\n  v <- sum( ( a1^2 - a2^2 ) / down )\n  w <- 2 * sum( a1 * a2  / down )\n  a <- atan2( sqrt(v^2 + w^2), u )\n",
        "  b <- atan2( w, v )\n  n <- dim(y)[1]\n\n  ka <- optimize( lik, c(0, 1000), maximum = TRUE, tol = 1e-7 )\n  k <- ka$maximum\n  se.mod <- sqrt( diag( solve(mod$hessian) ) )\n  se.a <- sqrt( (1 - exp( - 2 * k)) / (1 + exp(- 2* k ) ) / (n * k) )\n  se.b <- 1 / ( k * ( 1 + exp(-2 * k) ) / ( 1 - exp(- 2 * k) ) * sin(a)^2 )\n  se.k <- sqrt( 1 / ( 1 / k^2 - 2 / ( exp(k) - exp(- k) ) ) ) / sqrt(n)\n\n  confgam <- c(gam - qnorm(0.975) * se.mod[1], gam + qnorm(0.975) * se.mod[1] )\n  confgam <- confgam / pi * 180\n  confdel <- c(del - qnorm(0.975) * se.mod[2], del + qnorm(0.975) * se.mod[2] )\n",
        "  confdel <- confdel / pi * 180\n  confa <- c(a - qnorm(0.975) * se.a, a + qnorm(0.975) * se.a )\n  confa <- confa / pi * 180\n  confb <- c(b - qnorm(0.975) * se.b, b + qnorm(0.975) * se.b )\n  confb <- confb / pi * 180\n  confk <- c(k - qnorm(0.975) * se.k, k + qnorm(0.975) * se.k )\n\n  info <- rbind( c(gam / pi * 180, confgam), c(del / pi * 180, confdel), c(a / pi * 180, confa),\n                 c(b / pi * 180, confb),  c(k, confk) )\n  rownames(info) <- c(\"gamma\", \"delta\", \"alpha\", \"beta\", \"kappa\")\n  colnames(info) <- c(\"estimate\", \"2.5%\", \"97.5%\")\n",
        "  modes <- rbind( c(a, b/2), c(a, b/2 + pi) )\n  modes <- modes / pi * 180\n  rownames(modes) <- c(\"mode 1\", \"mode 2\")\n  colnames(modes) <- c(\"co-latitude\", \"longitude\")\n  unitvectors <- cbind(m1, m2, m3)\n  colnames(unitvectors) <- c(\"mu 1\", \"mu 2\", \"mu 3\")\n  list( info = info, modes = modes, unitvectors = unitvectors, loglik = ka$objective - n * log(2 * pi)  )\n}\n<bytecode: 0x000001f306dc2b10>\n<environment: namespace:Directional>\n\nRestarting R session...\n\n",
        "> ",
        "library(MLE)",
        "Warning message:\n",
        "package ‘bp’ was built under R version 4.3.3 \n",
        "\nRestarting R session...\n\n"
    ]
}